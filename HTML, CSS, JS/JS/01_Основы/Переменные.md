В JS существуют 3 варианта объявить переменную:
- var
- let
- const

Для создания переменной в JavaScript используется  `let`.
```javascript
let message;
```

В старых скриптах можно найти `var` вместо `let`:

```javascript
var message = 'Hello';
```

`var` – _почти_ то же самое, что и `let`. Оно также объявляет переменную, но немного по-другому. Это ваше "по-другому" заключается в том что для `var` не существует блочной области видимости, т.е области видимости ограничивается либо функцией, либо скриптом, если переменная глобальная. Решается это путем эмуляции этой блочной видимости. Раньше существовал такой способ как «Immediately-invoked function expressions» (сокращенно IIFE). Выглядит это следующим образом:
```javascript
(function() {
  var Hui = "Хуек";
  alert(Hui); 
})();
```

Здесь создаётся и немедленно вызывается Function Expression. Так что код выполняется сразу же и у него есть свои локальные переменные.

Function Expression обёрнуто в скобки `(function {...})`, потому что, когда JavaScript встречает `"function"` в основном потоке кода, он воспринимает это как начало Function Declaration. Но у Function Declaration должно быть имя, иначе получим пизды:

``` JS
function() { //SyntaxError: Function statements require a function name
  var Hui = "Хуек";
  alert(Hui); 
}();
```

Да даже если мы просто назовем функцию, мы все равно опиздюлимся, поскольку сам JS не позволяет вызывать Function Declaration немедленно.

``` JS
function Huek() { //SyntaxError: Function statements require a function name
  var Hui = "Хуек";
  alert(Hui); 
}(); //SyntaxError: Unexpected token ')'
```

Так что скобки вокруг функции – это трюк, который позволяет объяснить JavaScript, что функция была создана в контексте другого выражения, а значит, что это Function Expression: ей не нужно имя и её можно вызвать немедленно.

Помимо круглых скобок существуют и другие способы сообщить JavaScript, что мы имеем в виду Function Expression:

```javascript
// Способы создания IIFE

(function() {
  var Hui = "Хуек";
  alert(Hui); //"Круглые скобки вокруг функции"
})();

(function() {
  var Hui = "Хуек";
  alert(Hui); //"Круглые скобки вокруг всего выражения"
}());

!function() {
  var Hui = "Хуек";
  alert(Hui); //"Выражение начинается с логического оператора НЕ"
}();

+function() {
  var Hui = "Хуек";
  alert(Hui); //"Выражение начинается с унарного плюса"
}();
```

Во всех перечисленных случаях мы объявляем Function Expression и немедленно запускаем его. Ещё раз отметим: в настоящее время необходимости писать подобный код нет.

Но вернемся к нам баранам

`var` допускает повторное объявление. Если при попытке через `let` повторно объявить переменную, то можно получить пизды.

``` JS
let user;
let user; // SyntaxError: 'user' has already been declared
```

А `var` похуй, переменную можно переобъявлять сколько твоей душе заблагорасудиться. 

Так же объявленные переменные через `var` обрабатываются в начале выполнения функции (или запуска скрипта, если переменная является глобальной).

Другими словами, переменные `var` считаются объявленными с самого начала исполнения функции вне зависимости от того, в каком месте функции реально находятся их объявления (при условии, что они не находятся во вложенной функции). 

```javascript
function sayNyaaa() {
  Nyaaa = "Няяя, блять";
  alert(Nyaaa);
  var Nyaaa;
}
sayNyaaa();
```

Пример выше эквивалентен примеру ниже. Все из-за отсутствия блочной области видимости. Вот такая хуйня происходит. Сиё поведение называется "hoisting" (всплытие, поднятие), все потому что объявления переменных `var` «всплывают» в самый верх функции.

``` JS
function sayNyaaa() {
  var Nyaaa;
  Nyaaa = "Няяя, блять";
  alert(Nyaaa);
}
sayNyaaa();
```

Но...

``` JS
function sayNyaaa() {
  Nyaaa = "Няяя, блять";
  
  if(false){
	var Nyaaa;	
	}
  
  alert(Nyaaa);
}
sayNyaaa();
```

Если мы воткнем какое-нибудь условие. То это условие никогда не выполнится. Но это никоим образом не препятствует созданию переменной `var Nyaaa`, которая находится внутри него, поскольку объявления `var` «всплывают» в начало функции. Т.е. в момент присвоения значения, переменная уже существует.

Объявление переменной обрабатывается в начале выполнения функции , однако присвоение значения всегда происходит в той строке кода, где оно указано. 

```javascript
function sayNyaaa() {
  var Nyaaa;
  alert(Nyaaa); // undefined
  Nyaaa = "Няяя, блять";
}
sayNyaaa();
```

А поскольку все объявления переменных `var` обрабатываются в начале функции, мы можем ссылаться на них в любом месте. Однако, переменные имеют значение `undefined` до строки с присвоением значения.

Чтобы объявить неизменяемую переменную или константу используется `const`:

```javascript
const myBirthday = '15.01.1997';
```

Переменные, объявленные с помощью `const`, называются «константами». Их нельзя изменить. Попытка сделать это приведёт к ошибке.
```javascript
const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // TypeError: Assignment to constant variable.
```

Если уверен, что переменная никогда не будет меняться, объяви её через `const`.

Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.

Названия таких констант пишутся с использованием заглавных букв и подчёркивания.

Например, константы для различных цветов в «HEX-формате»:
```javascript
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

Понятное дело, проще запомнить название переменной чем сам HEX-формат, да и читать код проще.

Если есть константы, которые _вычисляются_ во время выполнения скрипта, то лучше записать строчным. Иными словами, константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений.