## Че такое JavaScript?

JS это высокоуровненый интрепетируемый язык програмирования, используемый для написания Front-end и (с недавный пор) Back-end части сайта, а также мобильных приложених. Сей язык добавляет сайту интерактивности. Во frontend-части сайта язык использутся для создания интерактива (анимаций, всплывающих форм, автозаполнения), так как он связан с HTML и CSS и может ими манипулировать. В backend-части с языком JavaScript работают на платформе Node.js. С ее помощью, например, разрабатывают серверные веб-приложения и подключают библиотеки. В поисковике Google на JavaScript работает строка автозаполнения, а Netflix, Uber, eBay используют его в своем backend.

JavaScript простыми словами называют языком **скриптов или сценариев**. **Скрипты** — это набор инструкций, которые выполняются при загрузке страницы. Браузер самостоятельно интерпретирует код на JavaScript, для этого даже не требуется компиляция 

## Как подрубается?

Скрипты можно прописать внутри кода страницы или подключить к HTML отдельным файлом. 

В стандартной разметке html-документа JS-код прописывают внутрь тега script, помещенного в body.

``` HTML
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Документ</title>
	</head>
	<body>
		<h1>Hello, World JavaScript</h1>
		<script>
			console.log('Привет, мир!');
		</script>
	</body>
</html>
```

Но обычно создается скрипт отдельным файлом с раcширением `.js` и прописывается вот таким образом:

``` HTML
<body>
	<h1>Привет!</h1>
	<script src="js/script.js"></script>
</body>
</html>
```

Сам тег `<script>` имеет несколько атрибутов:
- `type` Во старом HTML4, было требования наличествоания сего атрибута в данном теге. Обычно он имел значение `type="text/javascript"`. Сейчас оно нахуй больше не нужно. Более того, в современном стандарте HTML смысл этого атрибута полностью изменился. Теперь он может использоваться для JavaScript-модулей.

- `language` Сей атрибут задает язык на котором написать сей скрипт. Но поскольку JS язык по дефолту. Смысла в данном атрибуте нет.

- `src` Как и в CSS нужен для указания пути к файлу. 

- В очень древних книгах и руководствах можно найти комментарии внутри тега `<script>`:
``` HTML
<script type="text/javascript"><!--
    ...
//--></script>
```
Этот комментарий скрывал код JavaScript в старых браузерах, которые не знали, как обрабатывать тег `<script>`. Поскольку все браузеры, выпущенные за последние 15 лет, не содержат данной проблемы, такие комментарии уже не нужны. Если они есть, то это признак, что перед нами очень древний код.

В одном теге `<script>` нельзя использовать одновременно атрибут `src` и код внутри.

Нижеприведённый пример не работает:

``` JS
<script src="file.js">
  alert(1); // содержимое игнорируется, так как есть атрибут src
</script>
```

Нужно выбрать: либо внешний скрипт `<script src="…">`, либо обычный код внутри тега `<script>`.

Вышеприведённый пример можно разделить на два скрипта:

```JS
<script src="file.js"></script>
<script>
  alert(1);
</script>
```

## Нужна или не нужна ;?

В JS в большинстве случаев точку с запятой можно не ставить, если есть переход на новую строку.
```javascript
alert('Привет')
alert('Мир')
```

В этом случае JavaScript интерпретирует перенос строки как «неявную» точку с запятой. Это называется [автоматическая вставка точки с запятой.](https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion)

**В большинстве случаев новая строка подразумевает точку с запятой. Но «в большинстве случаев» не значит «всегда»!*

Но лучше ставить точку с запятой между строчками кода, даже если они отделены переносами строк. Это правило широко используется в сообществе разработчиков. 

## Комментарии

Однострочные комментарии начинаются с двойной косой черты `//`.
```javascript
// Этот комментарий занимает всю строку
alert('Привет');

alert('Мир'); // Этот комментарий следует за инструкцией
```

Многострочные комментарии начинаются косой чертой со звёздочкой `/*` и заканчиваются звёздочкой с косой чертой `*/`.
```javascript
/* Пример с двумя сообщениями.
Это - многострочный комментарий.
*/
alert('Привет');
alert('Мир');
```

Тут все также как и в любом другом ЯПе. Нахуя я это написал? Хз.

## Переменные

Как мы знаем переменная – это «именованное хранилище» для данных. 

Для создания переменной в JavaScript используется  `let`.
```javascript
let message;
```

В старых скриптах можно найти `var` вместо `let`:

```javascript
var message = 'Hello';
```

`var` – _почти_ то же самое, что и `let`. Оно также объявляет переменную, но немного по-другому. Это ваше "по-другому" заключается в том что для `var` не существует блочной области видимости, т.е области видимости ограничивается либо функцией, либо скриптом, если переменная глобальная. Решается это путем эмуляции этой блочной видимости. Раньше существовал такой способ как «Immediately-invoked function expressions» (сокращенно IIFE). Выглядит это следующим образом:
```javascript
(function() {
  var Hui = "Хуек";
  alert(Hui); 
})();
```

Здесь создаётся и немедленно вызывается Function Expression. Так что код выполняется сразу же и у него есть свои локальные переменные.

Function Expression обёрнуто в скобки `(function {...})`, потому что, когда JavaScript встречает `"function"` в основном потоке кода, он воспринимает это как начало Function Declaration. Но у Function Declaration должно быть имя, иначе получим пизды:

``` JS
function() { //SyntaxError: Function statements require a function name
  var Hui = "Хуек";
  alert(Hui); 
}();
```

Да даже если мы просто назовем функцию, мы все равно опиздюлимся, поскольку сам JS не позволяет вызывать Function Declaration немедленно.

``` JS
function Huek() { //SyntaxError: Function statements require a function name
  var Hui = "Хуек";
  alert(Hui); 
}(); //SyntaxError: Unexpected token ')'
```

Так что скобки вокруг функции – это трюк, который позволяет объяснить JavaScript, что функция была создана в контексте другого выражения, а значит, что это Function Expression: ей не нужно имя и её можно вызвать немедленно.

Помимо круглых скобок существуют и другие способы сообщить JavaScript, что мы имеем в виду Function Expression:

```javascript
// Способы создания IIFE

(function() {
  var Hui = "Хуек";
  alert(Hui); //"Круглые скобки вокруг функции"
})();

(function() {
  var Hui = "Хуек";
  alert(Hui); //"Круглые скобки вокруг всего выражения"
}());

!function() {
  var Hui = "Хуек";
  alert(Hui); //"Выражение начинается с логического оператора НЕ"
}();

+function() {
  var Hui = "Хуек";
  alert(Hui); //"Выражение начинается с унарного плюса"
}();
```

Во всех перечисленных случаях мы объявляем Function Expression и немедленно запускаем его. Ещё раз отметим: в настоящее время необходимости писать подобный код нет.

Но вернемся к нам баранам

`var` допускает повторное объявление. Если при попытке через `let` повторно объявить переменную, то можно получить пизды.

``` JS
let user;
let user; // SyntaxError: 'user' has already been declared
```

А `var` похуй, переменную можно переобъявлять сколько твоей душе заблагорасудиться. 

Так же объявленные переменные через `var` обрабатываются в начале выполнения функции (или запуска скрипта, если переменная является глобальной).

Другими словами, переменные `var` считаются объявленными с самого начала исполнения функции вне зависимости от того, в каком месте функции реально находятся их объявления (при условии, что они не находятся во вложенной функции). 

```javascript
function sayNyaaa() {
  Nyaaa = "Няяя, блять";
  alert(Nyaaa);
  var Nyaaa;
}
sayNyaaa();
```

Пример выше эквивалентен примеру ниже. Все из-за отсутствия блочной области видимости. Вот такая хуйня происходит. Сиё поведение называется "hoisting" (всплытие, поднятие), все потому что объявления переменных `var` «всплывают» в самый верх функции.

``` JS
function sayNyaaa() {
  var Nyaaa;
  Nyaaa = "Няяя, блять";
  alert(Nyaaa);
}
sayNyaaa();
```

Но...

``` JS
function sayNyaaa() {
  Nyaaa = "Няяя, блять";
  
  if(false){
	var Nyaaa;	
	}
  
  alert(Nyaaa);
}
sayNyaaa();
```

Если мы воткнем какое-нибудь условие. То это условие никогда не выполнится. Но это никоим образом не препятствует созданию переменной `var Nyaaa`, которая находится внутри него, поскольку объявления `var` «всплывают» в начало функции. Т.е. в момент присвоения значения, переменная уже существует.

Объявление переменной обрабатывается в начале выполнения функции , однако присвоение значения всегда происходит в той строке кода, где оно указано. 

```javascript
function sayNyaaa() {
  var Nyaaa;
  alert(Nyaaa); // undefined
  Nyaaa = "Няяя, блять";
}
sayNyaaa();
```

А поскольку все объявления переменных `var` обрабатываются в начале функции, мы можем ссылаться на них в любом месте. Однако, переменные имеют значение `undefined` до строки с присвоением значения.

Чтобы объявить неизменяемую переменную или константу используется `const`:

```javascript
const myBirthday = '15.01.1997';
```

Переменные, объявленные с помощью `const`, называются «константами». Их нельзя изменить. Попытка сделать это приведёт к ошибке.
```javascript
const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // TypeError: Assignment to constant variable.
```

Если уверен, что переменная никогда не будет меняться, объяви её через `const`.

Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.

Названия таких констант пишутся с использованием заглавных букв и подчёркивания.

Например, константы для различных цветов в «HEX-формате»:
```javascript
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

Понятное дело, проще запомнить название переменной чем сам HEX-формат, да и читать код проще.

Если есть константы, которые _вычисляются_ во время выполнения скрипта, то лучше записать строчным. Иными словами, константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений.

## Взаимодействие

В браузерном JS есть три команды: `alert`, `prompt`, `confirm`.

`alert` выводит информацию модальным окном.

`prompt` содержит в себе два аргумента:

`prompt(title, [default])
`title` - текст, который надо отобразить.
`[default]` - устанавливает начальное значение в поле для текста в окне. Необязателен. 

`prompt` может вернуть текст, указанный в поле для ввода или `null` если ввод отменен юзером. 

`confirm` - выводит информацию и ждет, когда юзер нажмет ОК или Отмена, при нажатии Ок возвращает `true`, либо `false` при отмене.

## Преобразования

Операторы и функции чаще всего автоматически приводят значения к нужному типу. `alert` сам приводит любое значение к строке. Мат. операторы преобразуют к числам.

### Строковое преобразование
Строковое преобразование происходит, когда требуется представление чего-либо в виде строки.

Например, alert(value) преобразует значение к строке.

Также мы можем использовать функцию String(value), чтобы преобразовать значение к строке:
``` JS
let value = true;
alert(typeof value); // boolean

value = String(value); // теперь value это строка "true"
alert(typeof value); // string
```

### Численное преобразование

Приведение к числу происходит в мат. функциях и выражениях.

Можно использовать функцию `Number()`, чтобы явно преобразовать к числу. Явное преобразование часто юзается, когда мы ожидаем получить число из строки. Если строка не может приведена к число, то результатом будет `NaN`

Правила численного преобразования:

|Значение         |	Преобразуется в… |
| --------------- | ---------------- |
|`undefined`      |	`NaN`            |
|`null` 	        | 0                |
|`true` / `false` | 1 / 0            |
|`string`	        | Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN. |


### Логическое преобразования

Булевое преобразование происходит в логических операциях. Может явно преобразовано при помощи функции Boolean(). 

  - Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
  - Все остальные значения становятся `true`.

  Однако, строка с нулем - это `true`, любая не пустая строка - это `true`