## 3.1. Базовая настройка и софт

- Утилита Reflector отсортирует доступные репозитории по скорости:
```
sudo pacman -S reflector rsync curl 

sudo reflector --verbose --country 'Germany' -l 25 --sort rate --save /etc/pacman.d/mirrorlist
```

- Установка yay
```
git clone https://aur.archlinux.org/yay.git && cd yay && makepkg -sric
```

- Шрифт для канзи, хираганы, катаканы
~~~
sudo pacman -S adobe-source-han-serif-jp-fonts
~~~

- Для работы с архивами ставим:
~~~
sudo pacman -S lrzip unrar unzip unace p7zip squashfs-tools unarchiver zip file-roller
~~~

- Мой набор прикладного ПО
~~~
sudo pacman -S qbittorrent firefox vlc vlc-plugin-aom vlc-plugin-ffmpeg vlc-plugin-firewire vlc-plugin-freetype vlc-plugin-jack vlc-plugin-mad vlc-plugin-matroshka vlc-plugin-quicksync vlc-plugin-srt vlc-plugin-x264 vlc-plugin-x265 vlc-plugin-udev kitty
~~~

На kitty ставим [ZSH](obsidian://open?vault=obsidian&file=Linux%2F%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0%20ZSH)

- Visual Studio Code из проприетарного репозитория Microsoft
```
yay -S visual-studio-code-bin
```

- Steam
~~~
sudo pacman -S steam ttf-liberation wine wine-mono winetricks
~~~

- Ставим Телегу и ДС
```
sudo pacman -S telegram-desktop discord
```

#### 3.2 Установка и настройка драйверов NVIDIA

> Перед установкой драйвера отключаем к хуям _"Secure Boot"_ в UEFI, ибо из-за этого модули драйвера могут не загрузиться.

- NVIDIA ~~*"пидорасы из Санта Клары"*~~
~~~
sudo pacman -S nvidia-dkms nvidia-utils lib32-nvidia-utils nvidia-settings lib32-opencl-nvidia opencl-nvidia libxnvctrl vulkan-icd-loader lib32-vulkan-icd-loader libva-nvidia-driver
~~~
> ==Warning==
> Для правильной работы DKMS требуется также установить заголовки текущей версии ядра. Например, для стандартного ядра `linux` заголовки требуемые для сборки модулей находится внутри пакета `linux-headers`.
#### 3.2.1 Включаем KMS

> ***KMS - специальной подсистемы отвечающей за настройку режимов (разрешения/частоты обновления***

Совершенно обязательный шаг для обладателей карточек от зеленых пидорсов из Санта Клары это включение поддержки Kernel Mode Setting устройств вывода изображения (*встроенного дисплея или монитора*) на уровне ядра.

Для того чтобы включить KMS в драйвере NVIDIA необходимо создать файл `/etc/modprobe.d/nvidia-kms.conf`
~~~
sudo nano /etc/modprobe.d/nvidia-kms.conf

/etc/modprobe.d/nvidia-kms.conf
options nvidia_drm modeset=1
~~~

> Примечание
> Начиная с версии драйвера 545.xx через пробел можно указать параметр `fbdev=1` для задействования аппаратного ускорения фреймбуфера. 

#### 3.2.2 Специальные переменные окружения

Эти переменные можно указать в Litris или в аргументах запуска в Steam.

> После указания всех переменных обязательно в конце "_%command%_", для того чтобы Steam понимал, что указаны именно системные переменные окружения для запуска игры, а не параметры специфичные для этой самой игры

`__GL_THREADED_OPTIMIZATIONS=1` **(По умолчанию выключено)** - Активируем многопоточную обработку OpenGL. Используете выборочно для нативных игр/приложений, ибо иногда может наоборот вызывать регрессию производительности. Некоторые игры и вовсе могут не запускаться с данной переменной (К примеру, некоторые нативно-запускаемые части Metro).

`__GL_MaxFramesAllowed=1` **(По умолчанию - 2)** - Задает тип буферизации кадров драйвером. Можете указать значение _"3"_ (Тройная буферизация) для большего количества FPS и улучшения производительности в приложениях/играх с VSync. Мы рекомендуем задавать вовсе _"1"_ (т.е. не использовать буферизацию, подавать кадры так как они есть). Это может заметно уменьшить значение FPS в играх, но взамен вы получите лучшие задержки отрисовки и реальный физический отклик, т.к. кадр будет отображаться вам сразу на экран без лишних этапов его обработки.

`__GL_YIELD="USLEEP"` **(По умолчанию без значения)** - Довольно специфичный параметр, _"USLEEP"_ - снижает нагрузку на CPU и некоторым образом помогает в борьбе с тирингом, а _"NOTHING"_ дает больше FPS при этом увеличивая нагрузку на процессор.

`__GL_SHADER_DISK_CACHE_SKIP_CLEANUP=1` **(По умолчанию 0)** - отключает ограничение кэша шейдеров OpenGL/Vulkan (по умолчанию располагается по пути `~/.cache/nvidia`). Рекомендуется для современных нативных игр и DXVK 2.0+, где размер кэша может достигать более гигабайта.

`__GL_SYNC_DISPLAY_DEVICE` - указывает монитор с частотой которого драйвер NVIDIA будет осуществлять синхронизацию. Это нужно для конфигураций с двумя и более мониторами для предотвращения заиканий на дисплеях с высокой частотой обновления на некоторых композиторах (например Muffin). Представим, что у вас есть два дисплея, один 144 Гц, другой 60. В переменную следует указать видеовыход, в который подключен монитор с наибольшей частотой обновления. Чтобы определить какой монитор, в какой выход подключен можно использовать утилиту `xrandr`. Данную переменную имеет смысл указывать глобально, то есть в файле `/etc/environment`

~~~ Arch
sudo nano /etc/environment

 __GL_SYNC_DISPLAY_DEVICE=HDMI-0
~~~

#### 3.2.3 Добавляем модули в образ initramfs
~~~
sudo nano /etc/mkinitcpio.conf.d/10-modules.conf

/etc/mkinitcpio.conf.d/10-modules.conf
MODULES+=(nvidia nvidia_modeset nvidia_uvm nvidia_drm btrfs zlib_deflate crc32c libcrc32c)
~~~

После добавления модулей обязательно нужно пересобрать ядро 
```
sudo mkinitcpio -P
```
## 3.2 Чистим мусор

Хочешь быструю систему - снеси нахуй весь не нужный софт

- GNOME 
~~~
sudo pacman -D --asdeps $(pacman -Qqg gnome)
	sudo pacman -D --asexplicit gnome-shell mutter gdm gnome-control-center gnome-console nautilus gnome-session gnome-settings-daemon gvfs gvfs-mtp
sudo pacman -Rsn $(pacman -Qqgdtt gnome)
~~~

-  KDE Plasma
~~~
sudo pacman -D --asdeps $(pacman -Qqg plasma)
sudo pacman -D --asexplicit plasma-desktop breeze-gtk kde-gtk-config plasma-pa bluedevil sddm sddm-kcm plasma-nm
sudo pacman -Rsn $(pacman -Qqgdtt plasma)
~~~

## 3.3 Базовая оптимизация системы

Прежде чем приступать к оптимизации Arch, настроим makepkg.conf. 
### 3.3.1 makepkg.conf

Для это делаем юзерский конфиг `~/.makepkg.conf` в домашней директории, чтобы переопределить системные настройки:

~~~
nano ~/.makepkg.conf

CFLAGS="-march=native -mtune=native -O2 -pipe -fno-plt -fexceptions \
      -Wp,-D_FORTIFY_SOURCE=3 -Wformat -Werror=format-security \
      -fstack-clash-protection -fcf-protection"
CXXFLAGS="$CFLAGS -Wp,-D_GLIBCXX_ASSERTIONS"
RUSTFLAGS="-C opt-level=3 -C target-cpu=native -C link-arg=-z -C link-arg=pack-relative-relocs"
MAKEFLAGS="-j$(nproc) -l$(nproc)"
~~~

### 3.3.2 Юзаем tmpfs для сборки в ОЗУ
Для ускорения процесса сборки пакетов можно использовать вместо HDD/SSD - оперативную память, а точнее _tmpfs_.

Использовать tmpfs для makepkg можно несколькими способами:

- Непосредственно указывать переменную перед сборкой:
~~~
BUILDDIR=/tmp/makepkg makepkg -sric
~~~

- Для сборки всего - задать параметр `BUILDDIR` для использования директории `/tmp`:
~~~
BUILDDIR=/tmp/makepkg
~~~

- Создать отдельную директорию _tmpfs_ заданного размера:
	- Необходимо добавить в `/etc/fstab` директорию для монтирования _tmpfs_
   ~~~
     tmpfs /var/tmp/makepkg tmpfs rw,nodev,nosuid,size=16G          0  0 
     ~~~
	
	- Далее, указать `BUILDDIR` в `/etc/makepkg.conf`, но уже с путем к директории указанной в _fstab_

> На системах с небольшим количеством ОЗУ (например 4 ГБ и менее) _tmpfs_ может негативно сказаться на сборке тяжёлых пакетов, ибо ОЗУ будет не хватать

> Можно указать параметр PKGDEST для определения директории собранного пакета.

Количество доступного и используемого места в _tmpfs_ можно посмотреть:
~~~
df -h | grep tmpfs
~~~

### 3.3.3 Включаем ccache

Для компиляции таких программ как Wine/Proton-GE врубаем ccache

> ccache - это кэш для компиляторов C/C++, в частности совместимый с компиляторами GCC/Clang, цель которого состоит в ускорении повторного процесса компиляции одного и того же кода. .

- Для начала ставим пакет
~~~
sudo pacman -S ccache
~~~

- Активируем в настройках makepkg. Для этого отредактируем `~/.makepkg.conf`
~~~
BUILDENV=(!distcc color ccache check !sign)
~~~

 > ccache может ломать сборку некоторых программ, поэтому осторожно с ним.

### 3.3.4 Включаем zram-generator

[zram-generator](https://aur.archlinux.org/packages/zram-generator/) — демон для создания блочных устройств ZRAM. ZRAM - это альтернативный механизм подкачки в ядре Linux, который позволяет избавиться от обычной подкачки на диске и сжимать неиспользуемые данные прямо внутри памяти ресурсами CPU.

### 3.3.5 Включаем systemd-oomd

~~~
sudo systemctl enable --now systemd-oomd
~~~

### 3.3.6 Ставим Ananicy CPP

~~~
git clone https://aur.archlinux.org/ananicy-cpp.git && cd ananicy-cpp &&
makepkg -sric &&
sudo systemctl enable --now ananicy-cpp &&
cd .. && rm -rf ananicy-cpp 
~~~

##### TRIM

[TRIM](https://ru.wikipedia.org/wiki/Trim_(команда_для_накопителей)) - это встроенная команда контроллера для очищения уже неиспользуемых ячеек на твердотельном накопителе. Её очень полезно периодически выполнять с целью профилактики SSD.

~~~
sudo systemctl enable fstrim.timer
~~~

Если используем не systemd то:
~~~
sudo fstrim -v /
~~~

> Предупреждение
> Если .юзаешь  Btrfs и ее версия ядра 6.2 и выше, то выполнять включение службы для осуществления периодическего выполнения команды TRIM - не нужно, т. к. Btrfs сам выполняет её в асинхронном режиме.

##### Автоматическая очистка кэша pacman
Кэш пакетов pacman имеет очень хуёвое свойство забиваться и со временем занимает много места на диске. Чтобы этого не происходило, сделаем небольшой демон, который будет автоматически его очищать, например, каждую неделю. В этом нам могут встроенные средства systemd для создания таймеров.

- Для этого сначала создадим службу `pacman-cleaner.service`:
~~~
/etc/systemd/system/pacman-cleaner.service
[Unit]
Description=Cleans pacman cache

[Service]
Type=oneshot
ExecStart=/usr/bin/pacman -Scc --noconfirm

[Install]
WantedBy=multi-user.target
~~~

- После создания службы, сделаем для него таймер `pacman-cleaner.timer`:
~~~
/etc/systemd/system/pacman-cleaner.timer
[Unit]
Description=Run clean of pacman cache every week

[Timer]
OnCalendar=weekly
AccuracySec=1h // <- Здесь задаем интервал срабатывания
Persistent=true

[Install]
WantedBy=timers.target
~~~

- А теперь запустим
~~~
sudo systemctl enable --now pacman-cleaner.timer
~~~

##### irqbalance

[irqbalance](https://github.com/Irqbalance/irqbalance) - это демон, что автоматически балансирует обработку прерываний по ядрам процессора.

~~~
sudo pacman -S irqbalance
sudo systemctl enable --now irqbalance
~~~

##### Отрубаем к хуям мусорные службы
###### Службы индексирования файлов
В Linux как и в Винде есть службы индексирования поиска, которая занимается тем, что в фоновом режиме проходит по всей файловой системе в поисках новых файлов или каталогов, чтобы внести их в собственную базу, которая будет использована для ускорения встроенного поиска или поиска в файловом менеджере. На первый взгляд все звучит заебись, но на практике жрет память, как хром, и нагружает диск.

В Linux подобные службы есть только у рабочих окружений GNOME и KDE Plasma. В KDE Plasma встроенным файловым индексатором является Baloo, который отличается своей склонностью часто "подтекать" с точки зрения потребления памяти, а в GNOME есть Tracker 3, который хоть и менее прожорливый по сравнению с аналогом от KDE, но все ещё потребляет не мало ресурсов.

Так как отрубаем всех подобных служб может положительно влиять на жизнь диска:

- **GNOME** 
~~~
systemctl --user mask tracker-extract-3 tracker-miner-fs-3 tracker-miner-fs-control-3 tracker-miner-rss-3 tracker-writeback-3 tracker-xdg-portal-3
rm -rf ~/.cache/tracker ~/.local/share/tracker
~~~

- **KDE Plasma**
~~~
balooctl6 suspend
balooctl6 disable
balooctl6 purge
~~~

###### Юзерские службы GNOME

GSD (gnome-settings-daemon) - службы настройки GNOME и связанных приложений. Это просто службы-настройки на все случаи жизни, которые просто жрут оперативную память в ожидании когда тебе, или другому приложению, к примеру, понадобиться настроить или интегрировать поддержку планшета Wacom в рабочее окружение, или для уведомления о различных событиях, таких как недостаточное место на диске или начале печати, а также для применения изменений совершенных в настройках GNOME на лету. 

Че можно отрубить к хуям?

- Служба интеграции рабочего окружения с графическим планшетом Wacom. Позволяет настраивать яркость планшета средствами окружения.

~~~
systemctl --user mask org.gnome.SettingsDaemon.Wacom.service
~~~

- Служба уведомления о начале печати. Если нет принтера или просто они нахуй не нужны.

~~~
systemctl --user mask org.gnome.SettingsDaemon.PrintNotifications.service
~~~

- Служба управления цветовыми профилями дисплея и принтеров. Если его отключить, то не будет работать тёплый режим экрана (Системный аналог Redshift):

~~~
systemctl --user mask org.gnome.SettingsDaemon.Color.service
~~~

- Служба управления специальными возможностями системы:
~~~
systemctl --user mask org.gnome.SettingsDaemon.A11ySettings.service
~~~

- Служба управления беспроводными интернет-подключениями и Bluetooth.
~~~
systemctl --user mask org.gnome.SettingsDaemon.Wwan.service
systemctl --user mask org.gnome.SettingsDaemon.Rfkill.service
~~~

- Службы защиты от неавторизованных USB устройств при блокировке экрана:
~~~
systemctl --user mask org.gnome.SettingsDaemon.UsbProtection.service
~~~

- Службу для автоматической блокировки экрана:
~~~
systemctl --user mask org.gnome.SettingsDaemon.ScreensaverProxy.service
~~~

- Служба для автоматического управления общим доступом к файлам и директориям:

~~~
systemctl --user mask org.gnome.SettingsDaemon.Sharing.service
~~~

- Служба интеграции рабочего окружения с карт-ридером:
~~~
systemctl --user mask org.gnome.SettingsDaemon.Smartcard.service
~~~



























##### Низкие задержки звука
[PipeWire](https://wiki.archlinux.org/title/PipeWire_(Русский)) - заебцовая альтернатива PulseAudio, которая призвана избавить от проблем PulseAudio, уменьшить задержки звука и потребление памяти. Внатуре охуенная вещь.

- Ставим Pipewire и запускаем службу
~~~
sudo pacman -S pipewire pipewire-pulse pipewire-jack lib32-pipewire gst-plugin-pipewire wireplumber realtime-privileges rtkit
systemctl --user enable --now pipewire pipewire.socket pipewire-pulse wireplumber
~~~

- Добавляем себя в группу `realtime`
~~~
sudo usermod -aG realtime "$USER"
~~~

- Создадим пути для хранения конфигурационных файлов в домашней директории:

~~~
mkdir -p ~/.config/pipewire/pipewire.conf.d
~~~

- В созданной директории создадим файл `10-no-resampling.conf`

~~~
nano ~/.config/pipewire/pipewire.conf.d/10-no-resampling.conf

10-no-resampling.conf
 context.properties = {
   default.clock.rate = 48000
   default.clock.allowed-rates = [ 44100 48000 96000 192000 ]
 }
~~~

Фактически здесь мы настраиваем две вещи: первое, это частота дискретизации, используемая по умолчанию `defalut.clock.rate`, в зависимости от которой PipeWire так же считает оптимальные задержки для вывода звука, а именно значения `quantum`. Во-вторых, мы явно перечисляем все доступные частоты дискретизации `defalut.clock.allowed-rates`, поддерживаемые нашим устройством вывода звука (. Это нужно для того, чтобы PipeWire не делал ресемплирования, то есть изменения частоты дискретизации исходного аудиопотока к частоте используемой по умолчанию, что может повлечь за собой ухудшение качества итогового звучания, а также дополнительные накладные расходы в виде нагрузки на CPU.

Важно отметить, что PipeWire выполняет переключение между указанными частотами дискретизации только в состоянии покоя непосредственно перед началом вывода нового аудиопотока, однако если вы начинаете проигрывать ещё один аудиопоток, то PipeWire не поменяет частоту дискретизации с учетом второго аудиопотока, а продолжит использовать ту же частоту дискретизации, что и у первого, и это может опять же привести к ситуации ресемплинга второго аудиопотока до уровня первого. В случае же если первоначальный аудиопоток не попадал в указанный диапозон частот, то он также бы ресемплировался от целовой к самой "ближайшей" частоте из перечисленных.

Чтобы узнать весь диапозон частот доступных для вашего устройства:

**Звуковой чип**
~~~
cat /proc/asound/card0/codec\#0 | grep -A 8 "Audio Output" -m 1 | grep rates
~~~

**ЦАП**
~~~
cat /proc/asound/card0/stream0 | grep Rates | uniq
~~~

Частоты, которые были получены таким образом, нужно прописать через пробел взамен тех, что даны в примере выше. Если доступно несколько устройств, то при помощи команды `cat /proc/asound/cards` узнайте номер звуковой карты, которая используется непосредственно для вывода звука, и подставьте его в команду выше.



~~~
- Включаем службу-таймер для обновления ключей 
``` Arch
sudo systemctl enable --now archlinux-keyring-wkd-sync.timer



-  Включение 32-битного репозитория
~~~ Arch
sudo nano /etc/pacman.conf           

Раскоментируем последние две строчки 
 [multilib]
 Include = /etc/pacman.d/mirrorlist
~~~

- Ставим reflector и rsync
~~~ Arch
sudo pacman -S reflector rsync
~~~
Reflector'ом ставим германские зеркала ибо они наиболее свежие и быстрые (для европейскиой части РФ)
~~~
sudo reflector --verbose --country 'Germany' -l 25 --sort rate --save /etc/pacman.d/mirrorlist
~~~
Если за границей то в комманде выше меняет Germany на Russia или ту страну в которой находишься.

Можно вручную добавлять зеркала из https://archlinux.org/mirrorlist/

~~~ Arch

sudo nano /etc/pacman.d/mirrorlist
~~~
